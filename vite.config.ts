import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';
import { SvelteKitPWA } from "@vite-pwa/sveltekit";
import type { KitOptions  } from "@vite-pwa/sveltekit";
import type { ManifestEntry, ManifestTransform } from "workbox-build";
import crypto from "node:crypto";
import fs from "node:fs";
import { resolve as resolveFs } from "node:path";

export default defineConfig({
	plugins: [
		sveltekit(),
		SvelteKitPWA({
			strategies: "injectManifest",
			registerType: "autoUpdate",
			filename: "service-worker.ts",
			injectManifest: {
				manifestTransforms: [createManifestTransform('/', undefined, {
					adapterFallback: "app.html",
				})],
			},
			kit: {
				adapterFallback: "app.html",
			},
			manifest: {
				id: "/",
				short_name: "SvelteKit PWA Issue",
				name: "SvelteKit PWA",
				description: "Small reproduction of the fallback issue with SvelteKit",
				display_override: ["window-controls-overlay"],
				display: "standalone",
				dir: "ltr",
				theme_color: "#0d6dfd",
				background_color: "#212529",
				edge_side_panel: {
					preferred_width: 400,
				},
				handle_links: "preferred",
				orientation: "portrait-primary",
				prefer_related_applications: false,
				related_applications: [],
				launch_handler: {
					client_mode: "navigate-existing",
				},
				screenshots: [],
			},

			pwaAssets: {
				config: true,
			},

			devOptions: {
				enabled: true,
				type: "module",
			},
		}),
	],
});

function buildManifestEntry(url: string, path: string): Promise<ManifestEntry & { size: number }> {
	return new Promise((resolve, reject) => {
		const cHash = crypto.createHash('MD5')
		const stream = fs.createReadStream(path)
		stream.on('error', (err) => {
			reject(err)
		})
		stream.on('data', (chunk) => {
			cHash.update(chunk)
		})
		stream.on('end', () => {
			return resolve({
				url,
				size: stream.bytesRead,
				revision: `${cHash.digest('hex')}`,
			})
		})
	})
}

function createManifestTransform(base: string, webManifestName?: string, options?: KitOptions): ManifestTransform {
	return async (entries) => {
		const defaultAdapterFallback = 'prerendered/fallback.html'
		const suffix = options?.trailingSlash === 'always' ? '/' : ''
		let adapterFallback = options?.adapterFallback
		let excludeFallback = false
		// the fallback will be always generated by SvelteKit.
		// The adapter will copy the fallback only if it is provided in its options: we need to exclude it
		if (!adapterFallback) {
			adapterFallback = defaultAdapterFallback
			excludeFallback = true
		}

		// the fallback will be always in .svelte-kit/output/prerendered/fallback.html
		const manifest = entries
			.filter(({ url }) => !(excludeFallback && url === defaultAdapterFallback))
			.map((e) => {
				let url = e.url
				// client assets in `.svelte-kit/output/client` folder.
				// SSG pages in `.svelte-kit/output/prerendered/pages` folder.
				// fallback page in `.svelte-kit/output/prerendered` folder (fallback.html is the default).
				if (url.startsWith('client/'))
					url = url.slice(7)
				else if (url.startsWith('prerendered/pages/'))
					url = url.slice(18)
				else if (url === defaultAdapterFallback)
					url = adapterFallback!

				if (url.endsWith('.html')) {
					if (url.startsWith('/'))
						url = url.slice(1)

					if (url === 'index.html') {
						url = base
					}
					else {
						const idx = url.lastIndexOf('/')
						if (idx > -1) {
							// abc/index.html -> abc/?
							if (url.endsWith('/index.html'))
								url = `${url.slice(0, idx)}${suffix}`
							// abc/def.html -> abc/def/?
							else
								url = `${url.substring(0, url.lastIndexOf('.'))}${suffix}`
						}
						else {
							// xxx.html -> xxx/?
							url = `${url.substring(0, url.lastIndexOf('.'))}${suffix}`
						}
					}
				}

				e.url = url

				return e
			})

		// use the version.json file hash as the revision for the app.html file
		manifest.push(await buildManifestEntry('app.html', resolveFs('.svelte-kit/output/client/_app/version.json')))

		if (!webManifestName)
			return { manifest }

		return { manifest: manifest.filter(e => e.url !== webManifestName) }
	}
}
